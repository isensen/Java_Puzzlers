package _01_One;

/**
 * Created with IntelliJ IDEA.
 * User: i33
 * Date: 13-6-21
 * Time: 上午11:27
 */
public class _08_DosEquis {

    public static void main(String[] args){
        char x = 'X';
        int i = 0;

        //X
        System.out.println(true ? x : 0);
        //88
        System.out.println(false ? i : x);

        /*
        规范有关条件表达式部分的一个阴暗的角落里。请注意在这两个表达式中，每一个表达式的第二个和第三个操作数的类型都不相同：
        x是char类型的，而0和i都是int类型的。就像在谜题5的解答中提到的，混合类型的计算会引起混乱，而这一点比在条件表达式中
        比在其它任何地方都表现得更明显。你可能考虑过，这个程序中两个条件表达式的结果类型是相同的，就像它们的操作数类型是相
        同的一样，尽管操作数的顺序颠倒了一下，但是实际情况并非如此。

        确定条件表达式结果类型的规则过于冗长和复杂，很难完全记住它们，但是其核心就是一下三点：

        •	如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。换句话说，你可以通过绕过混合类型的计算来避免大麻烦。
        •	如果一个操作数的类型是T，T表示byte、short或char，而另一个操作数是一个int类型的常量表达式(注意是常量表达式,不是变量)，
            它的值是可以用类型T表示的，那么条件表达式的类型就是T。
        •	否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。


        2、3两点对本谜题是关键。在程序的两个条件表达式中，一个操作数的类型是char，另一个的类型是int。在两个表达式中，int操作数都
        是0，它可以被表示成一个char。然而，只有第一个表达式中的int操作数是常量（0），而第二个表达式中的int操作数是变量（i）。因
        此，第2点被应用到了第一个表达式上，它返回的类型是char，而第3点被应用到了第二个表达式上，其返回的类型是对int和char运用了
        二进制数字提升之后的类型，即int。

        条件表达式的类型将确定哪一个重载的print方法将被调用。对第一个表达式来说，PrintStream.print(char)将被调用，而对第二个表
        达式来说，PrintStream.print(int)将被调用。前一个重载方法将变量x的值作为Unicode字符（X）来打印，而后一个重载方法将其作
        为一个十进制整数（88）来打印。至此，谜题被解开了。

        总之，通常最好是在条件表达式中使用类型相同的第二和第三操作数。否则，你和你的程序的读者必须要彻底理解这些表达式行为的复杂规范

        对语言设计者来说，也许可以设计一个牺牲掉了部分灵活性，但是增加了简洁性的条件操作符。例如，要求第二和第三操作数必须就有相同
        的类型，这看起来就很合理。或者，条件操作符可以被定义为对常量没有任何特殊处理。为了让这些选择对程序员来说更加容易接受，可以
        提供用来表示所有原始类型字面常量的语法。这也许确实是一个好注意，因为它增加了语言的一致性和完备性，同时又减少了对转型的需求。

        */

    }

}
