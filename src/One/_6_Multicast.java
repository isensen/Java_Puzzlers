package One;

/**
 * Created with IntelliJ IDEA.
 * User: i33
 * Date: 13-6-19
 * Time: 上午11:13
 */
public class _6_Multicast {
    public static void main(String[] args){

        //连续使用了三个转型。那么它到底会打印出什么呢
        //65535
        System.out.println((int)(char)(byte) -1);

        /*
          1. int数值-1开始，然后从int转型为byte
             第一个转型将数值从32位窄化到了8位
          2. 第二个转型将数值从8位拓宽到了16位
          3. 最后一个转型又将数值从16位拓宽回了32位。
        */

        /*
          该程序的行为紧密依赖于转型的符号扩展行为。Java使用了基于2的补码的二进制运算，
          因此int类型的数值-1的所有32位都是置位的。从int到byte的转型是很简单的，它执
          行了一个窄化原始类型转化（narrowing primitive conversion），直接将除低8位
          外的所有位全部砍掉。这样做留下的是一个8位都被置位了的byte，它仍旧表示-1。

          从byte到char的转型稍微麻烦一点，因为byte是一个有符号类型，而char是一个无符号类
          。在将一个整数类型转换成另一个宽度更宽的整数类型时，通常是可以保持其数值的，但
          是却不可能将一个负的byte数值表示成一个char。因此，从byte到char的转换被认为不是
          一个拓宽原始类型的转换，而是一个拓宽并窄化原始类型的转换（widening and narrowing
          primitive conversion）：byte被转换成了int，而这个int又被转换成了char。

          所有这些听起来有点复杂，幸运的是，有一条很简单的规则能够描述从较窄的整型转换成较宽
          的整型时的符号扩展行为：如果最初的数值类型是有符号的，那么就执行符号扩展；如果它是
          char，那么不管它将要被转换成什么类型，都执行零扩展。了解这条规则可以使我们很容易地
          解决这个谜题。

          因为byte是一个有符号的类型，所以在将byte数值-1转换成char时，会发生符号扩展。作为
          结果的char数值的16个位就都被置位了，因此它等于216-1，即65535。从char到int的转型
          也是一个拓宽原始类型转换，所以这条规则告诉我们，它将执行零扩展而不是符号扩展。作为
          结果的int数值也就成了65535，这正是程序打印出的结果。

          如果你在将一个char数值c转型为一个宽度更宽的类型，并且你不希望有符号扩展，那么为清
          晰表达意图，可以考虑使用一个位掩码，即使它并不是必需的：

            int i = c & 0xffff;
            或者，书写一句注释来描述转换的行为：
            int i = c; //不会执行符号扩展

          如果你在将一个char数值c转型为一个宽度更宽的整型，并且你希望有符号扩展，那么就先将
          char转型为一个short，它与char具有同样的宽度，但是它是有符号的。在给出了这种细微的
          代码之后，你应该也为它书写一句注释：

            int i = (short) c; //转型将引起符号扩展

          如果你在将一个byte数值b转型为一个char，并且你不希望有符号扩展，那么你必须使用一个
          位掩码来限制它。这是一种通用做法，所以不需要任何注释：

            char c = (char) (b & 0xff);

          这个教训很简单：如果你通过观察不能确定程序将要做什么，那么它做的就很有可能不是你想
          要的。要为明白清晰地表达你的意图而努力。尽管有这么一条简单的规则，描述了涉及有符号
          和无符号整型拓宽转换的符号扩展行为，但是大多数程序员都不知道它。如果你的程序依赖于
          它，那么你就应该把你的意图表达清楚。

        */

    }
}
